// Package portin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package portin

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// Defines values for PortInOrderPostRequestProcessType.
const (
	PortInOrderPostRequestProcessTypeGOS           PortInOrderPostRequestProcessType = "GOS"
	PortInOrderPostRequestProcessTypeLongTimePort  PortInOrderPostRequestProcessType = "LongTimePort"
	PortInOrderPostRequestProcessTypeShortTimePort PortInOrderPostRequestProcessType = "ShortTimePort"
)

// Defines values for PortInOrderResponseProcessType.
const (
	PortInOrderResponseProcessTypeGOS           PortInOrderResponseProcessType = "GOS"
	PortInOrderResponseProcessTypeLongTimePort  PortInOrderResponseProcessType = "LongTimePort"
	PortInOrderResponseProcessTypeShortTimePort PortInOrderResponseProcessType = "ShortTimePort"
)

// AuthorizedPerson Данные представителя юр. лица
type AuthorizedPerson struct {
	// FirstName Имя
	FirstName string `json:"firstName"`

	// LastName Фамилия
	LastName string `json:"lastName"`

	// MiddleName Отчество
	MiddleName *string `json:"middleName,omitempty"`

	// Position Должность представителя.
	Position *string `json:"position,omitempty"`
}

// CdbProcessId Идентификатор процесса БДПН 16 цифр
type CdbProcessId = string

// Company Данные клиента юридического лица
type Company struct {
	// AuthorizedPerson Данные представителя юр. лица
	AuthorizedPerson *AuthorizedPerson `json:"authorizedPerson,omitempty"`

	// Customer Ссылка на клиента МТС
	Customer *PartyRef `json:"customer,omitempty"`

	// IdDocuments документы организации
	IdDocuments *[]IdDocument `json:"idDocuments,omitempty"`

	// Inn ИНН компании
	Inn string `json:"inn"`

	// Name название компании
	Name string `json:"name"`

	// Numbers Список абонентских номеров,
	// ассоциированных с текущим объектом
	// персональных данных. Каждый номер –
	// строка в формате с кодом страны 71234567890
	Numbers *[]Phone `json:"numbers,omitempty"`
}

// ErrorResponse Информация об ошибке обработки запроса
type ErrorResponse struct {
	// Code код ошибки
	Code *string `json:"code,omitempty"`

	// Message сообщение об ошибке
	Message *string `json:"message,omitempty"`
}

// Government Данные клиента - правительственной организации
type Government struct {
	// AuthorizedPerson Данные представителя юр. лица
	AuthorizedPerson *AuthorizedPerson `json:"authorizedPerson,omitempty"`

	// ContractDueDate Дата переноса по контракту тендера. Дата-время в ISO-8601
	ContractDueDate *time.Time `json:"contractDueDate,omitempty"`

	// Customer Ссылка на клиента МТС
	Customer *PartyRef `json:"customer,omitempty"`

	// IdDocuments документы организации
	IdDocuments *[]IdDocument `json:"idDocuments,omitempty"`

	// Inn ИНН компании
	Inn string `json:"inn"`

	// Name название компании
	Name string `json:"name"`

	// Numbers Список абонентских номеров,
	// ассоциированных с текущим объектом
	// персональных данных. Каждый номер –
	// строка в формате с кодом страны 71234567890
	Numbers *[]Phone `json:"numbers,omitempty"`

	// TenderId идентификатор тендера
	TenderId *string `json:"tenderId,omitempty"`

	// TradingFloor Тендерная площадка
	TradingFloor *string `json:"tradingFloor,omitempty"`
}

// IdDocument Документ удостоверения личности
type IdDocument struct {
	// DocName Название удостоверяющего документа
	DocName *string `json:"docName,omitempty"`

	// DocNumber номер
	DocNumber string `json:"docNumber"`

	// DocSeries серия
	DocSeries *string `json:"docSeries,omitempty"`

	// DocType Тип документа
	DocType *string `json:"docType,omitempty"`

	// DocumentUrl путь к скан-копии
	DocumentUrl *string `json:"documentUrl,omitempty"`
}

// Individual Данные клиента индивидуального предпринимателя
type Individual struct {
	// Customer Ссылка на клиента МТС
	Customer *PartyRef `json:"customer,omitempty"`

	// FirstName Имя
	FirstName *string `json:"firstName,omitempty"`

	// IdDocuments Список идентификационных документов клиента
	IdDocuments []IdDocument `json:"idDocuments"`

	// Inn Номер налогоплательщика
	Inn *string `json:"inn,omitempty"`

	// LastName Фамилия
	LastName *string `json:"lastName,omitempty"`

	// LegalCategory Статус резидент/нерезидент
	LegalCategory *string `json:"legalCategory,omitempty"`

	// MiddleName Отчество
	MiddleName *string `json:"middleName,omitempty"`

	// Numbers Список абонентских номеров,
	// ассоциированных с текущим объектом
	// персональных данных. Каждый номер –
	// строка в формате с кодом страны 71234567890
	Numbers *[]Phone `json:"numbers,omitempty"`
}

// MnpDocumentRef Ссылка на подписанный документ заявление на перенос номера
type MnpDocumentRef struct {
	// DocumentDate Дата подписания заявления
	DocumentDate *time.Time `json:"documentDate,omitempty"`

	// DocumentUrl URL файла заявления
	DocumentUrl string `json:"documentUrl"`

	// Id Идентификатор документа в системе документооборота
	Id *string `json:"id,omitempty"`
}

// MnpOrderRef Ссылка на заявку PortInOrder
type MnpOrderRef struct {
	// Id Идентификатор заявки переноса номера.
	// Уникальность обеспечивается парой id и orderType
	Id *string `json:"id,omitempty"`

	// OrderType Тип заявки MNP
	// для portIn это PortInOrder
	OrderType *string `json:"orderType,omitempty"`
}

// Operator Региональный оператор подвижной связи
type Operator struct {
	// CdbCode Кодовое название оператора в ЦБДПН
	CdbCode *string `json:"cdbCode,omitempty"`

	// Mnc MNC код оператора
	Mnc *string `json:"mnc,omitempty"`

	// Name Название оператора
	Name *string `json:"name,omitempty"`

	// NetworkOperator Ссылка на Network Operator в Telco.ROI
	NetworkOperator *string `json:"networkOperator,omitempty"`

	// Region Регион
	Region *Region `json:"region,omitempty"`

	// Rn Маршрутный номер оператора
	Rn string `json:"rn"`
}

// OrderState Состояние заявки
type OrderState struct {
	// Code Код статуса
	Code string `json:"code"`

	// Message Сообщение причины статуса
	Message *string `json:"message,omitempty"`

	// Name Название статуса
	Name *string `json:"name,omitempty"`

	// StatusDate Дата установки статуса
	StatusDate *time.Time `json:"statusDate,omitempty"`
}

// PartyRef Ссылка на клиента МТС
type PartyRef struct {
	// Id Идентификатор клиента в экосистеме МТС
	Id string `json:"id"`
}

// Person Данные клиента физического лица
type Person struct {
	// Customer Ссылка на клиента МТС
	Customer *PartyRef `json:"customer,omitempty"`

	// FirstName Имя
	FirstName string `json:"firstName"`

	// IdDocuments Список идентификационных документов клиента
	IdDocuments []IdDocument `json:"idDocuments"`

	// LastName Фамилия
	LastName string `json:"lastName"`

	// LegalCategory Статус резидент/нерезидент
	LegalCategory *string `json:"legalCategory,omitempty"`

	// MiddleName Отчество
	MiddleName *string `json:"middleName,omitempty"`

	// Numbers Список абонентских номеров,
	// ассоциированных с текущим объектом
	// персональных данных. Каждый номер –
	// строка в формате с кодом страны 71234567890
	Numbers *[]Phone `json:"numbers,omitempty"`
}

// Phone Номер телефона РФ без разделителей с кодом страны
type Phone = string

// PortInOrderPostRequest Данные для создания новой или изменения заявки на портацию мобильного номера клиента в сеть оператора-реципиента из сети опреатора-донора
type PortInOrderPostRequest struct {
	// Comment Текстовый комментарий
	Comment *string `json:"comment,omitempty"`

	// Company Данные клиента юридического лица
	Company *Company `json:"company,omitempty"`

	// Contract Ссылка на подписанный документ заявление на перенос номера
	Contract MnpDocumentRef `json:"contract"`

	// Donor Региональный оператор подвижной связи
	Donor *Operator `json:"donor,omitempty"`

	// DueDate Запланированная дата переноса номера. Дата-время в ISO-8601
	DueDate time.Time `json:"dueDate"`

	// Government Данные клиента - правительственной организации
	Government *Government `json:"government,omitempty"`

	// Individual Данные клиента индивидуального предпринимателя
	Individual *Individual `json:"individual,omitempty"`

	// Person Данные клиента физического лица
	Person *Person `json:"person,omitempty"`

	// PortationNumbers Список портируемых номеров в заявке. Каждый портируемый номер связан с аккаунтом в Telco, указывающим на сим карту и временный номер
	PortationNumbers []PortationNumber `json:"portationNumbers"`

	// ProcessType Тип процесса переноса номера:
	// ShortTimePort - Процесс, предусматривающий сроки этапов портации для физ. лица. Может применяться как для физ. лиц, так и для ИП и юр. лиц с ограничением епо количеству номеров в одной заявке.
	// LongTimePort - Процесс, предусматривающий сроки этапов портации для юр лиц. Может применяться для юр лиц.
	// GOS - Процесс, предусматривающий сроки этапов портации для гос. контрактов. Может применяться только для гос. контрактов
	ProcessType *PortInOrderPostRequestProcessType `json:"processType,omitempty"`

	// Recipient Региональный оператор подвижной связи
	Recipient *Operator `json:"recipient,omitempty"`

	// Source Источник создания заявки, сообщенный при ее создании. Если в заголовке передан x-caller, то поле заполнять нет необходимости, оно будет сохранено значеним x-caller
	Source *string `json:"source,omitempty"`
}

// PortInOrderPostRequestProcessType Тип процесса переноса номера:
// ShortTimePort - Процесс, предусматривающий сроки этапов портации для физ. лица. Может применяться как для физ. лиц, так и для ИП и юр. лиц с ограничением епо количеству номеров в одной заявке.
// LongTimePort - Процесс, предусматривающий сроки этапов портации для юр лиц. Может применяться для юр лиц.
// GOS - Процесс, предусматривающий сроки этапов портации для гос. контрактов. Может применяться только для гос. контрактов
type PortInOrderPostRequestProcessType string

// PortInOrderResponse Заявка на портацию мобильного номера клиента в сеть оператора-реципиента из сети опреатора-донора
type PortInOrderResponse struct {
	// CdbProcessId Идентификатор процесса БДПН 16 цифр
	CdbProcessId *CdbProcessId `json:"cdbProcessId,omitempty"`

	// Comment Текстовый комментарий
	Comment *string `json:"comment,omitempty"`

	// Company Данные клиента юридического лица
	Company *Company `json:"company,omitempty"`

	// Contract Ссылка на подписанный документ заявление на перенос номера
	Contract *MnpDocumentRef `json:"contract,omitempty"`

	// Donor Региональный оператор подвижной связи
	Donor *Operator `json:"donor,omitempty"`

	// DueDate Запланированная дата переноса номера. Дата-время в ISO-8601
	DueDate *time.Time `json:"dueDate,omitempty"`

	// Government Данные клиента - правительственной организации
	Government *Government `json:"government,omitempty"`

	// Id Идентификатор заказа. Уникальный для всех заявок MNP HUB
	//
	// Генерируется при создании новой заявки PortIn
	Id string `json:"id"`

	// Individual Данные клиента индивидуального предпринимателя
	Individual *Individual `json:"individual,omitempty"`

	// Person Данные клиента физического лица
	Person *Person `json:"person,omitempty"`

	// PortationNumbers Список портируемых номеров в заявке. Каждый портируемый номер связан с аккаунтом в Telco, указывающим на сим карту и временный номер
	PortationNumbers *[]PortationNumber `json:"portationNumbers,omitempty"`

	// ProcessType Тип процесса переноса номера:
	// ShortTimePort - Процесс, предусматривающий сроки этапов портации для физ. лица. Может применяться как для физ. лиц, так и для ИП и юр. лиц с ограничением епо количеству номеров в одной заявке.
	// LongTimePort - Процесс, предусматривающий сроки этапов портации для юр лиц. Может применяться для юр лиц.
	// GOS - Процесс, предусматривающий сроки этапов портации для гос. контрактов. Может применяться только для гос. контрактов
	ProcessType *PortInOrderResponseProcessType `json:"processType,omitempty"`

	// Recipient Региональный оператор подвижной связи
	Recipient *Operator `json:"recipient,omitempty"`

	// Source Источник создания заявки, сообщенный при ее создании
	Source *string `json:"source,omitempty"`

	// State Состояние заявки
	State OrderState `json:"state"`
}

// PortInOrderResponseProcessType Тип процесса переноса номера:
// ShortTimePort - Процесс, предусматривающий сроки этапов портации для физ. лица. Может применяться как для физ. лиц, так и для ИП и юр. лиц с ограничением епо количеству номеров в одной заявке.
// LongTimePort - Процесс, предусматривающий сроки этапов портации для юр лиц. Может применяться для юр лиц.
// GOS - Процесс, предусматривающий сроки этапов портации для гос. контрактов. Может применяться только для гос. контрактов
type PortInOrderResponseProcessType string

// PortationNumber Портируемый номер
type PortationNumber struct {
	// Msisdn Номер телефона РФ без разделителей с кодом страны
	Msisdn Phone `json:"msisdn"`

	// Status Состояние заявки
	Status *OrderState `json:"status,omitempty"`

	// TelcoAccount Ссылка на телеком аккаунт
	TelcoAccount TelcoAccountRef `json:"telcoAccount"`
}

// Region Регион
type Region struct {
	// Code Код субъекта РФ
	Code string `json:"code"`

	// Kladr КЛАДР региона
	Kladr *string `json:"kladr,omitempty"`

	// Name Название региона
	Name *string `json:"name,omitempty"`
}

// TelcoAccountRef Ссылка на телеком аккаунт
type TelcoAccountRef struct {
	// Id Идентификатор телеком аккаунта
	Id *string `json:"id,omitempty"`

	// Msisdn Номер телефона РФ без разделителей с кодом страны
	Msisdn *Phone `json:"msisdn,omitempty"`
}

// GetPortInOrdersParams defines parameters for GetPortInOrders.
type GetPortInOrdersParams struct {
	// Portnumber Портируемый номер телефона
	Portnumber *Phone `form:"portnumber,omitempty" json:"portnumber,omitempty"`

	// Tempnumber Временный номер телефона
	Tempnumber *Phone `form:"tempnumber,omitempty" json:"tempnumber,omitempty"`

	// CdbProcessId Поиск по идентификатору процесса БДПН
	CdbProcessId *CdbProcessId `form:"cdbProcessId,omitempty" json:"cdbProcessId,omitempty"`

	// XCaller Вызывающая система, которая выполняет запрос в текущий момент
	XCaller *string `json:"x-caller,omitempty"`

	// XMtsUser Доменное NTLM-имя оператора сервиса, под котором идет обращение
	XMtsUser *string `json:"x-mts-user,omitempty"`
}

// CreatePortInOrderParams defines parameters for CreatePortInOrder.
type CreatePortInOrderParams struct {
	// XCaller Вызывающая система, которая выполняет запрос в текущий момент
	XCaller *string `json:"x-caller,omitempty"`

	// XMtsUser Доменное NTLM-имя оператора сервиса, под котором идет обращение
	XMtsUser *string `json:"x-mts-user,omitempty"`
}

// GetPortInOrderParams defines parameters for GetPortInOrder.
type GetPortInOrderParams struct {
	// XCaller Вызывающая система, которая выполняет запрос в текущий момент
	XCaller *string `json:"x-caller,omitempty"`

	// XMtsUser Доменное NTLM-имя оператора сервиса, под котором идет обращение
	XMtsUser *string `json:"x-mts-user,omitempty"`
}

// CreatePortInOrderJSONRequestBody defines body for CreatePortInOrder for application/json ContentType.
type CreatePortInOrderJSONRequestBody = PortInOrderPostRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Поиск заявок PortIn по параметрам
	// (GET /mnphub/ordering/v1/portInOrders)
	GetPortInOrders(w http.ResponseWriter, r *http.Request, params GetPortInOrdersParams)
	// Создание новой заявки PortIn и запуск процесса переноса
	// (POST /mnphub/ordering/v1/portInOrders)
	CreatePortInOrder(w http.ResponseWriter, r *http.Request, params CreatePortInOrderParams)
	// Запрос заявки PortIn по ее id
	// (GET /mnphub/ordering/v1/portInOrders/{id})
	GetPortInOrder(w http.ResponseWriter, r *http.Request, id string, params GetPortInOrderParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Поиск заявок PortIn по параметрам
// (GET /mnphub/ordering/v1/portInOrders)
func (_ Unimplemented) GetPortInOrders(w http.ResponseWriter, r *http.Request, params GetPortInOrdersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Создание новой заявки PortIn и запуск процесса переноса
// (POST /mnphub/ordering/v1/portInOrders)
func (_ Unimplemented) CreatePortInOrder(w http.ResponseWriter, r *http.Request, params CreatePortInOrderParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Запрос заявки PortIn по ее id
// (GET /mnphub/ordering/v1/portInOrders/{id})
func (_ Unimplemented) GetPortInOrder(w http.ResponseWriter, r *http.Request, id string, params GetPortInOrderParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetPortInOrders operation middleware
func (siw *ServerInterfaceWrapper) GetPortInOrders(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPortInOrdersParams

	// ------------- Optional query parameter "portnumber" -------------

	err = runtime.BindQueryParameter("form", true, false, "portnumber", r.URL.Query(), &params.Portnumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "portnumber", Err: err})
		return
	}

	// ------------- Optional query parameter "tempnumber" -------------

	err = runtime.BindQueryParameter("form", true, false, "tempnumber", r.URL.Query(), &params.Tempnumber)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tempnumber", Err: err})
		return
	}

	// ------------- Optional query parameter "cdbProcessId" -------------

	err = runtime.BindQueryParameter("form", true, false, "cdbProcessId", r.URL.Query(), &params.CdbProcessId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cdbProcessId", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "x-caller" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-caller")]; found {
		var XCaller string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-caller", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-caller", valueList[0], &XCaller, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-caller", Err: err})
			return
		}

		params.XCaller = &XCaller

	}

	// ------------- Optional header parameter "x-mts-user" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-mts-user")]; found {
		var XMtsUser string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-mts-user", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-mts-user", valueList[0], &XMtsUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-mts-user", Err: err})
			return
		}

		params.XMtsUser = &XMtsUser

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPortInOrders(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePortInOrder operation middleware
func (siw *ServerInterfaceWrapper) CreatePortInOrder(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePortInOrderParams

	headers := r.Header

	// ------------- Optional header parameter "x-caller" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-caller")]; found {
		var XCaller string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-caller", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-caller", valueList[0], &XCaller, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-caller", Err: err})
			return
		}

		params.XCaller = &XCaller

	}

	// ------------- Optional header parameter "x-mts-user" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-mts-user")]; found {
		var XMtsUser string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-mts-user", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-mts-user", valueList[0], &XMtsUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-mts-user", Err: err})
			return
		}

		params.XMtsUser = &XMtsUser

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePortInOrder(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPortInOrder operation middleware
func (siw *ServerInterfaceWrapper) GetPortInOrder(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPortInOrderParams

	headers := r.Header

	// ------------- Optional header parameter "x-caller" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-caller")]; found {
		var XCaller string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-caller", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-caller", valueList[0], &XCaller, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-caller", Err: err})
			return
		}

		params.XCaller = &XCaller

	}

	// ------------- Optional header parameter "x-mts-user" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-mts-user")]; found {
		var XMtsUser string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-mts-user", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-mts-user", valueList[0], &XMtsUser, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-mts-user", Err: err})
			return
		}

		params.XMtsUser = &XMtsUser

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPortInOrder(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mnphub/ordering/v1/portInOrders", wrapper.GetPortInOrders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mnphub/ordering/v1/portInOrders", wrapper.CreatePortInOrder)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mnphub/ordering/v1/portInOrders/{id}", wrapper.GetPortInOrder)
	})

	return r
}

type GetPortInOrdersRequestObject struct {
	Params GetPortInOrdersParams
}

type GetPortInOrdersResponseObject interface {
	VisitGetPortInOrdersResponse(w http.ResponseWriter) error
}

type GetPortInOrders200JSONResponse []PortInOrderResponse

func (response GetPortInOrders200JSONResponse) VisitGetPortInOrdersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPortInOrders400JSONResponse ErrorResponse

func (response GetPortInOrders400JSONResponse) VisitGetPortInOrdersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetPortInOrders404JSONResponse ErrorResponse

func (response GetPortInOrders404JSONResponse) VisitGetPortInOrdersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetPortInOrders500JSONResponse ErrorResponse

func (response GetPortInOrders500JSONResponse) VisitGetPortInOrdersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreatePortInOrderRequestObject struct {
	Params CreatePortInOrderParams
	Body   *CreatePortInOrderJSONRequestBody
}

type CreatePortInOrderResponseObject interface {
	VisitCreatePortInOrderResponse(w http.ResponseWriter) error
}

type CreatePortInOrder200JSONResponse MnpOrderRef

func (response CreatePortInOrder200JSONResponse) VisitCreatePortInOrderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreatePortInOrder400JSONResponse ErrorResponse

func (response CreatePortInOrder400JSONResponse) VisitCreatePortInOrderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreatePortInOrder409JSONResponse ErrorResponse

func (response CreatePortInOrder409JSONResponse) VisitCreatePortInOrderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreatePortInOrder500JSONResponse ErrorResponse

func (response CreatePortInOrder500JSONResponse) VisitCreatePortInOrderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetPortInOrderRequestObject struct {
	Id     string `json:"id"`
	Params GetPortInOrderParams
}

type GetPortInOrderResponseObject interface {
	VisitGetPortInOrderResponse(w http.ResponseWriter) error
}

type GetPortInOrder200JSONResponse PortInOrderResponse

func (response GetPortInOrder200JSONResponse) VisitGetPortInOrderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPortInOrder400JSONResponse ErrorResponse

func (response GetPortInOrder400JSONResponse) VisitGetPortInOrderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetPortInOrder404JSONResponse ErrorResponse

func (response GetPortInOrder404JSONResponse) VisitGetPortInOrderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetPortInOrder500JSONResponse ErrorResponse

func (response GetPortInOrder500JSONResponse) VisitGetPortInOrderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Поиск заявок PortIn по параметрам
	// (GET /mnphub/ordering/v1/portInOrders)
	GetPortInOrders(ctx context.Context, request GetPortInOrdersRequestObject) (GetPortInOrdersResponseObject, error)
	// Создание новой заявки PortIn и запуск процесса переноса
	// (POST /mnphub/ordering/v1/portInOrders)
	CreatePortInOrder(ctx context.Context, request CreatePortInOrderRequestObject) (CreatePortInOrderResponseObject, error)
	// Запрос заявки PortIn по ее id
	// (GET /mnphub/ordering/v1/portInOrders/{id})
	GetPortInOrder(ctx context.Context, request GetPortInOrderRequestObject) (GetPortInOrderResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetPortInOrders operation middleware
func (sh *strictHandler) GetPortInOrders(w http.ResponseWriter, r *http.Request, params GetPortInOrdersParams) {
	var request GetPortInOrdersRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPortInOrders(ctx, request.(GetPortInOrdersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPortInOrders")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPortInOrdersResponseObject); ok {
		if err := validResponse.VisitGetPortInOrdersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreatePortInOrder operation middleware
func (sh *strictHandler) CreatePortInOrder(w http.ResponseWriter, r *http.Request, params CreatePortInOrderParams) {
	var request CreatePortInOrderRequestObject

	request.Params = params

	var body CreatePortInOrderJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePortInOrder(ctx, request.(CreatePortInOrderRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePortInOrder")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreatePortInOrderResponseObject); ok {
		if err := validResponse.VisitCreatePortInOrderResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPortInOrder operation middleware
func (sh *strictHandler) GetPortInOrder(w http.ResponseWriter, r *http.Request, id string, params GetPortInOrderParams) {
	var request GetPortInOrderRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPortInOrder(ctx, request.(GetPortInOrderRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPortInOrder")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPortInOrderResponseObject); ok {
		if err := validResponse.VisitGetPortInOrderResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
